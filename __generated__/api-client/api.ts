/* tslint:disable */
/* eslint-disable */
/**
 * CryptoAPIs
 * Crypto APIs 2.0 is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs 2.0 can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs 2.0 provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: developers@cryptoapis.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration"
import globalAxios, { AxiosPromise, AxiosInstance } from "axios"
// Some imports not used depending on template conditions
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setBearerAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from "./base"

/**
 *
 * @export
 * @interface DevicesActivateData
 */
export interface DevicesActivateData {
  /**
   *
   * @type {DevicesActivateDataItem}
   * @memberof DevicesActivateData
   */
  item: DevicesActivateDataItem
}
/**
 *
 * @export
 * @interface DevicesActivateDataItem
 */
export interface DevicesActivateDataItem {
  /**
   * Device activation code
   * @type {string}
   * @memberof DevicesActivateDataItem
   */
  activationCode: string
  /**
   * Client ID
   * @type {string}
   * @memberof DevicesActivateDataItem
   */
  clientId: string
  /**
   * User ID
   * @type {string}
   * @memberof DevicesActivateDataItem
   */
  userId: string
  /**
   * Device ID
   * @type {string}
   * @memberof DevicesActivateDataItem
   */
  deviceId: string
  /**
   * Device Info Data
   * @type {object}
   * @memberof DevicesActivateDataItem
   */
  deviceData: object
}
/**
 *
 * @export
 * @interface DevicesAuthenticateData
 */
export interface DevicesAuthenticateData {
  /**
   *
   * @type {DevicesAuthenticateDataItem}
   * @memberof DevicesAuthenticateData
   */
  item: DevicesAuthenticateDataItem
}
/**
 *
 * @export
 * @interface DevicesAuthenticateDataItem
 */
export interface DevicesAuthenticateDataItem {
  /**
   * Device activation code
   * @type {string}
   * @memberof DevicesAuthenticateDataItem
   */
  authCode: string
  /**
   * Client ID
   * @type {string}
   * @memberof DevicesAuthenticateDataItem
   */
  clientId: string
  /**
   * User ID
   * @type {string}
   * @memberof DevicesAuthenticateDataItem
   */
  userId: string
  /**
   * Device ID
   * @type {string}
   * @memberof DevicesAuthenticateDataItem
   */
  deviceId: string
}
/**
 *
 * @export
 * @interface ErrorError
 */
export interface ErrorError {
  /**
   * Specifies the error code
   * @type {string}
   * @memberof ErrorError
   */
  code: string
  /**
   * Specifies the message of the error
   * @type {string}
   * @memberof ErrorError
   */
  message: string
  /**
   * Optional details of the error
   * @type {object}
   * @memberof ErrorError
   */
  details?: object
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * Context in every request body must be \'mobile\'
   * @type {string}
   * @memberof InlineObject
   */
  context: string
  /**
   *
   * @type {DevicesActivateData}
   * @memberof InlineObject
   */
  data: DevicesActivateData
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   * Context in every request body must be \'mobile\'
   * @type {string}
   * @memberof InlineObject1
   */
  context: string
  /**
   *
   * @type {DevicesAuthenticateData}
   * @memberof InlineObject1
   */
  data: DevicesAuthenticateData
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse200
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse200
   */
  context: string
  /**
   *
   * @type {InlineResponse200Data}
   * @memberof InlineResponse200
   */
  data: InlineResponse200Data
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse2001
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse2001
   */
  context: string
  /**
   *
   * @type {InlineResponse2001Data}
   * @memberof InlineResponse2001
   */
  data: InlineResponse2001Data
}
/**
 *
 * @export
 * @interface InlineResponse2001Data
 */
export interface InlineResponse2001Data {
  /**
   *
   * @type {InlineResponse2001DataItem}
   * @memberof InlineResponse2001Data
   */
  item: InlineResponse2001DataItem
}
/**
 *
 * @export
 * @interface InlineResponse2001DataItem
 */
export interface InlineResponse2001DataItem {
  /**
   * Device access token
   * @type {string}
   * @memberof InlineResponse2001DataItem
   */
  accessToken: string
  /**
   * Access token type
   * @type {string}
   * @memberof InlineResponse2001DataItem
   */
  tokenType: string
  /**
   * Access token expiration time in seconds
   * @type {string}
   * @memberof InlineResponse2001DataItem
   */
  expiresIn: string
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse2002
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse2002
   */
  context: string
  /**
   *
   * @type {InlineResponse2002Data}
   * @memberof InlineResponse2002
   */
  data: InlineResponse2002Data
}
/**
 *
 * @export
 * @interface InlineResponse2002Data
 */
export interface InlineResponse2002Data {
  /**
   * Offset to start from
   * @type {number}
   * @memberof InlineResponse2002Data
   */
  offset: number
  /**
   * The numbers of items to return
   * @type {number}
   * @memberof InlineResponse2002Data
   */
  limit: number
  /**
   * Total items to list
   * @type {number}
   * @memberof InlineResponse2002Data
   */
  total: number
  /**
   *
   * @type {Array<InlineResponse2002DataItems>}
   * @memberof InlineResponse2002Data
   */
  items: Array<InlineResponse2002DataItems>
}
/**
 *
 * @export
 * @interface InlineResponse2002DataApprovals
 */
export interface InlineResponse2002DataApprovals {
  /**
   * ID of the approver/team member.
   * @type {string}
   * @memberof InlineResponse2002DataApprovals
   */
  teamMemberId: string
  /**
   * Timestamp of the approval.
   * @type {string}
   * @memberof InlineResponse2002DataApprovals
   */
  approvedTimestamp: string
  /**
   * Name of the approver/team member.
   * @type {string}
   * @memberof InlineResponse2002DataApprovals
   */
  name: string
}
/**
 *
 * @export
 * @interface InlineResponse2002DataDestinations
 */
export interface InlineResponse2002DataDestinations {
  /**
   * Destination address.
   * @type {string}
   * @memberof InlineResponse2002DataDestinations
   */
  address: string
  /**
   * Amount to send to the given address.
   * @type {string}
   * @memberof InlineResponse2002DataDestinations
   */
  amount: string
}
/**
 *
 * @export
 * @interface InlineResponse2002DataItems
 */
export interface InlineResponse2002DataItems {
  /**
   * ID of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  id: string
  /**
   * Status of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  status: string
  /**
   * Blockchain of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  blockchain: string
  /**
   * Network of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  network: string
  /**
   * Fee priority of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  feePriority: string
  /**
   * Context of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  context: string
  /**
   *
   * @type {Array<InlineResponse2002DataDestinations>}
   * @memberof InlineResponse2002DataItems
   */
  destinations: Array<InlineResponse2002DataDestinations>
  /**
   * Total amount of the current transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  amount: string
  /**
   * Timestamp of the transaction request.
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  createdTimestamp: string
  /**
   *
   * @type {Array<InlineResponse2002DataApprovals>}
   * @memberof InlineResponse2002DataItems
   */
  approvals?: Array<InlineResponse2002DataApprovals>
  /**
   * Required approvals for the transaction request to be processed.
   * @type {number}
   * @memberof InlineResponse2002DataItems
   */
  requiredApprovalsCount: number
  /**
   * ID of the Wallet
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  walletId: string
  /**
   * Name of the Wallet
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  walletName: string
  /**
   * Total amount of the current transaction request in USD
   * @type {string}
   * @memberof InlineResponse2002DataItems
   */
  amountInRelationUnitAsset: string
  /**
   * Required rejects for the transaction request to be processed.
   * @type {number}
   * @memberof InlineResponse2002DataItems
   */
  requiredRejectsCount: number
  /**
   *
   * @type {Array<InlineResponse2002DataRejects>}
   * @memberof InlineResponse2002DataItems
   */
  rejects: Array<InlineResponse2002DataRejects>
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2002DataItems
   */
  rejecters: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2002DataItems
   */
  approvers: Array<string>
  /**
   * If the current user can approve the transaction request.
   * @type {boolean}
   * @memberof InlineResponse2002DataItems
   */
  canApprove: boolean
  /**
   * If the current user can reject the transaction request.
   * @type {boolean}
   * @memberof InlineResponse2002DataItems
   */
  canReject: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2002DataRejects
 */
export interface InlineResponse2002DataRejects {
  /**
   * ID of the rejecter/team member.
   * @type {string}
   * @memberof InlineResponse2002DataRejects
   */
  teamMemberId: string
  /**
   * Timestamp of the reject.
   * @type {string}
   * @memberof InlineResponse2002DataRejects
   */
  rejectedTimestamp: string
  /**
   * Name of the rejecter/team member.
   * @type {string}
   * @memberof InlineResponse2002DataRejects
   */
  name: string
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse2003
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse2003
   */
  context: string
  /**
   *
   * @type {InlineResponse2003Data}
   * @memberof InlineResponse2003
   */
  data: InlineResponse2003Data
}
/**
 *
 * @export
 * @interface InlineResponse2003Data
 */
export interface InlineResponse2003Data {
  /**
   *
   * @type {InlineResponse2002DataItems}
   * @memberof InlineResponse2003Data
   */
  item: InlineResponse2002DataItems
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse2004
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse2004
   */
  context: string
  /**
   *
   * @type {InlineResponse2004Data}
   * @memberof InlineResponse2004
   */
  data: InlineResponse2004Data
}
/**
 *
 * @export
 * @interface InlineResponse2004Data
 */
export interface InlineResponse2004Data {
  /**
   *
   * @type {InlineResponse2004DataItem}
   * @memberof InlineResponse2004Data
   */
  item: InlineResponse2004DataItem
}
/**
 *
 * @export
 * @interface InlineResponse2004DataItem
 */
export interface InlineResponse2004DataItem {
  /**
   * Response status
   * @type {string}
   * @memberof InlineResponse2004DataItem
   */
  status: string
  /**
   * Response action
   * @type {string}
   * @memberof InlineResponse2004DataItem
   */
  action: string
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof InlineResponse2005
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof InlineResponse2005
   */
  context: string
  /**
   *
   * @type {InlineResponse2005Data}
   * @memberof InlineResponse2005
   */
  data: InlineResponse2005Data
}
/**
 *
 * @export
 * @interface InlineResponse2005Data
 */
export interface InlineResponse2005Data {
  /**
   *
   * @type {InlineResponse2005DataItem}
   * @memberof InlineResponse2005Data
   */
  item: InlineResponse2005DataItem
}
/**
 *
 * @export
 * @interface InlineResponse2005DataItem
 */
export interface InlineResponse2005DataItem {
  /**
   * Response status
   * @type {string}
   * @memberof InlineResponse2005DataItem
   */
  status: string
  /**
   * Response action
   * @type {string}
   * @memberof InlineResponse2005DataItem
   */
  action: string
}
/**
 *
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
  /**
   *
   * @type {InlineResponse200DataItem}
   * @memberof InlineResponse200Data
   */
  item: InlineResponse200DataItem
}
/**
 *
 * @export
 * @interface InlineResponse200DataItem
 */
export interface InlineResponse200DataItem {
  /**
   * Device authorization code
   * @type {string}
   * @memberof InlineResponse200DataItem
   */
  code: string
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Specifies the version of the API that incorporates this endpoint.
   * @type {string}
   * @memberof ModelError
   */
  apiVersion: string
  /**
   * Context in every response will be \'mobile\'
   * @type {string}
   * @memberof ModelError
   */
  context: string
  /**
   *
   * @type {ErrorError}
   * @memberof ModelError
   */
  error: ErrorError
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Activate Device
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateDevice: async (
      inlineObject?: InlineObject,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/devices/activate`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Approve Transaction by Id
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveTransactionById: async (txId: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'txId' is not null or undefined
      assertParamExists("approveTransactionById", "txId", txId)
      const localVarPath = `/waas/transactions-requests/{txId}/approve/`.replace(
        `{${"txId"}}`,
        encodeURIComponent(String(txId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)

      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Authenticate Device
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateDevice: async (
      inlineObject1?: InlineObject1,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/devices/authenticate`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List Awaiting Approval Transactions
     * @param {number} [offset] Offset to start from
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAwaitingApprovalTransactions: async (
      offset?: number,
      limit?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/waas/transactions-requests`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Reject Transaction by Id
     * @param {string} txId ID of the transaction to be rejected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectTransactionById: async (txId: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'txId' is not null or undefined
      assertParamExists("rejectTransactionById", "txId", txId)
      const localVarPath = `/waas/transactions-requests/{txId}/reject/`.replace(
        `{${"txId"}}`,
        encodeURIComponent(String(txId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Show Transaction Request Details
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTransactionRequestDetails: async (
      txId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'txId' is not null or undefined
      assertParamExists("showTransactionRequestDetails", "txId", txId)
      const localVarPath = `/waas/transactions-requests/{txId}`.replace(
        `{${"txId"}}`,
        encodeURIComponent(String(txId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Activate Device
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activateDevice(
      inlineObject?: InlineObject,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activateDevice(
        inlineObject,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Approve Transaction by Id
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async approveTransactionById(
      txId: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.approveTransactionById(
        txId,
        options,
      )

      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Authenticate Device
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authenticateDevice(
      inlineObject1?: InlineObject1,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateDevice(
        inlineObject1,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary List Awaiting Approval Transactions
     * @param {number} [offset] Offset to start from
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAwaitingApprovalTransactions(
      offset?: number,
      limit?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAwaitingApprovalTransactions(
        offset,
        limit,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Reject Transaction by Id
     * @param {string} txId ID of the transaction to be rejected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rejectTransactionById(
      txId: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rejectTransactionById(txId, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Show Transaction Request Details
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showTransactionRequestDetails(
      txId: string,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showTransactionRequestDetails(
        txId,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @summary Activate Device
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateDevice(inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp
        .activateDevice(inlineObject, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Approve Transaction by Id
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveTransactionById(txId: string, options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .approveTransactionById(txId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Authenticate Device
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateDevice(
      inlineObject1?: InlineObject1,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .authenticateDevice(inlineObject1, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List Awaiting Approval Transactions
     * @param {number} [offset] Offset to start from
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAwaitingApprovalTransactions(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .listAwaitingApprovalTransactions(offset, limit, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Reject Transaction by Id
     * @param {string} txId ID of the transaction to be rejected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectTransactionById(txId: string, options?: any): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .rejectTransactionById(txId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Show Transaction Request Details
     * @param {string} txId ID of the transaction to be approved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTransactionRequestDetails(txId: string, options?: any): AxiosPromise<InlineResponse2003> {
      return localVarFp
        .showTransactionRequestDetails(txId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary Activate Device
   * @param {InlineObject} [inlineObject]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public activateDevice(inlineObject?: InlineObject, options?: any) {
    return DefaultApiFp(this.configuration)
      .activateDevice(inlineObject, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Approve Transaction by Id
   * @param {string} txId ID of the transaction to be approved
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public approveTransactionById(txId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .approveTransactionById(txId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Authenticate Device
   * @param {InlineObject1} [inlineObject1]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authenticateDevice(inlineObject1?: InlineObject1, options?: any) {
    return DefaultApiFp(this.configuration)
      .authenticateDevice(inlineObject1, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List Awaiting Approval Transactions
   * @param {number} [offset] Offset to start from
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listAwaitingApprovalTransactions(offset?: number, limit?: number, options?: any) {
    return DefaultApiFp(this.configuration)
      .listAwaitingApprovalTransactions(offset, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Reject Transaction by Id
   * @param {string} txId ID of the transaction to be rejected
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rejectTransactionById(txId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .rejectTransactionById(txId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Show Transaction Request Details
   * @param {string} txId ID of the transaction to be approved
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public showTransactionRequestDetails(txId: string, options?: any) {
    return DefaultApiFp(this.configuration)
      .showTransactionRequestDetails(txId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
